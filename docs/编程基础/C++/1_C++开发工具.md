# C++ 开发工具

## makefile

!!!note
    Linux下直接安装gnumake，运行命令是```make```，Windows下可以安装gcc（配套有mingw32-make）
对于大型项目的编译，有成百上千个工程文件，根本不可能纯手工去指定如何编译。又比如，你修改了一个文件的某一行代码，难道你必须要把整个项目都又编译一次吗？这种时候Makefile就显得非常有用,makefile可以大写，也可以小写，一般Makefile首字母使用大写。

``` makefile
# 指定编译器
CC = gcc

# 编译选项，-I 用于指定头文件路径
CFLAGS = -Wall -g -I/path/to/libstemmer/include

# 链接选项，-L 用于指定库路径，-l 用于指定库名（这里假设库名为stemmer）
LDFLAGS = -L/path/to/libstemmer/lib -lstemmer

# 输出的可执行文件名
TARGET = main

# 源文件
SRCS = main.c

# 目标文件
OBJS = $(SRCS:.c=.o)

# 默认目标，编译可执行文件
all: $(TARGET)

# 链接目标文件，生成可执行文件
$(TARGET): $(OBJS)
    $(CC) $(CFLAGS) -o $(TARGET) $(OBJS) $(LDFLAGS)

# 生成目标文件
%.o: %.c
    $(CC) $(CFLAGS) -c $< -o $@

# 清理编译生成的文件
clean:
    rm -f $(OBJS) $(TARGET)

# 伪目标，不会与文件名冲突
.PHONY: all clean
```

## CMake

你是不是觉得makefile有些复杂，没有关系，我们还有CMake，它比makefile更适合跨平台，<del>你以后再也不用编写复杂的makefile了，可以编写更复杂的CMakeLists</del>。CMake在Linux下也是直接下载就可以了，Windows下去官网下载并配好环境变量，需要注意Windows下如果你没有使用VS，比如你用了VS Code，那么在输入CMake命令时需要指定编译器，假设你用的gcc，则输入```CMake -G "mingw32makefile" -b build -s .```

一个简单的示例，CMake能帮你做很多事，所以它会生成一堆中间文件，所以一般建议单独新建一个build文件夹来存放构建中间文件

```cmake
cmake_minimum_required(VERSION 3.5)
set(CMAKE_CXX_STANDARD 11)

# 包含头文件目录
include_directories(${PROJECT_SOURCE_DIR}/include)

# 获取所有源文件
file(GLOB SRC_LIST ${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp)

# 定义可执行文件
add_executable(main ${SRC_LIST})

# 设置可执行文件的输出目录为源文件目录
set_target_properties(main PROPERTIES
    RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/src
)
```

## vcpkg

C++不像后来的Python和Java有那种很智能的包管理器，但是终归还是有替代方案的，比如vcpkg，这个可以和 VS 适配，在配置一些比如OpenGL,OpenCV的库的时候很好用，与VS建立连接之后甚至可以自动导入环境，在实际使用时引用头文件就可以了
