# 标准库拾遗

!!!abstract
    C++标准库里面其实内容很丰富，有好些东西长期不用容易忘，以及随着C++标准迭代，标准库正变得越来越庞大

## iomanip

1. `std::setw(int n)`：设置输出的宽度为 `n` 个字符。
2. `std::setprecision(int n)`：设置浮点数的精度，表示小数点后保留 `n` 位。
3. `std::fixed` 和 `std::scientific`：设置浮点数的输出格式为定点格式或科学计数法。
4. `std::setfill(char c)`：设置填充字符，用于在输出宽度不足时填充。

## exception

类型excption仅仅定义了拷贝构造函数、拷贝赋值运算符、一个虚析构函数和一个名为what的虚成员。其中what函数返回一个const char* 类型的指针，并且确保不会发生任何异常。当然在它的基础上继承出异常类型。比如下面这个例子：

```cpp
if(item1.isbn()!=item2.isbn())
    throw runtime_error("Data must refer to same ISBN");
//runtime_error 是标准错误类型的一种，继承自 exception
cout << item1 + item2 << endl;
```

## utility

1. pair
2. tuple

## memory

1. alloctor
2. smart pointer

## limits

<limits>库提供了模板类std::numeric_limits，用于获取与类型相关的特性和极限值（如最小值、最大值、精度等）。这个库对于处理不同类型的变量（如整数、浮点数等）的极值和特性非常有用，尤其是在编写与数据范围相关的算法时。

``` cpp
#include <iostream>
#include <limits>

int main() {
    std::cout << "int 类型的最大值: " << std::numeric_limits<int>::max() << std::endl;
    std::cout << "int 类型的最小值: " << std::numeric_limits<int>::min() << std::endl;

    std::cout << "double 类型的最大值: " << std::numeric_limits<double>::max() << std::endl;
    std::cout << "double 类型的最小值: " << std::numeric_limits<double>::min() << std::endl;

    return 0;
}
```
