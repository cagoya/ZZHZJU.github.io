# C++ 杂项

!!!abstract
    众所周知，千万不要说你精通C++，C++的确是一门内容很复杂的语言

## 函数

### 带默认参数的函数

默认参数必须放在最后

### 函数重载

C++允许函数重载，即同名但参数不同的函数，是不是const之类的也可以触发重载

### lambda 表达式

C++ 中的 lambda 表达式是匿名函数的一种，用于创建内联的、可以在函数内部使用的小函数。它们使代码更加简洁，特别是在需要短小的函数对象时。要用好Labmda表达式并不简单。

```cpp
[capture](parameters) -> return_type {
    // function body
}
```

- **capture**：捕获列表，指定 lambda 函数如何捕获外部变量。可以使用 `[]` 表示不捕获，`[&]` 表示按引用捕获，`[=]` 表示按值捕获。
- **parameters**：参数列表，类似于普通函数的参数列表。如果没有参数，可以省略。
- **return_type**：返回类型，可以省略，由编译器自动推导。
- **function body**：函数体，lambda 表达式的具体实现。

## 正则表达式

其实很多语言都提供了正则表达式，语法上会有细微的差距

```
. 任意字符，除了换行符
\d 匹配数字字符(digital)
\w 匹配字母，数字，下划线(word)
\s 匹配空白字符，空格、制表符等(space)
* 匹配前面的字符0次或多次
+ 匹配前面的字符1次或多次
？匹配前面的字符0次或1次
[] 匹配括号中的所有字符
[^] 匹配除了括号里的东西的所有字符
$ 匹配输入字符串的结尾位置
^ 匹配输入字符串的开始位置，除非在方括号表达式中使用
| 指明两项之间的一个选择
{n} 匹配确定的 n 次
{n,} 至少匹配n 次
{n,m} 最少匹配 n 次且最多匹配 m 次
```

|符号|含义|
|----|----|
|i|不区分大小写|
|g|全局查找|
|m|多行匹配|

## 随机数

C的随机数是伪随机数，而且不方便调整范围、精度、分布等参数，C++提供了提供了更好的随机数库,在 C++ 中，可以使用标准库中的 <random> 头文件来生成随机数。

``` C++
#include <iostream>
#include <random>

int main() {
    // 1. 创建随机数引擎（Mersenne Twister 引擎）
    std::random_device rd; // 用于生成种子
    // mt19937 为32位无符号梅森旋转生成器
    std::mt19937 gen(rd());

    // 2. 定义分布范围
    std::uniform_int_distribution<> distrib_int(1, 100);   // 生成1到100之间的整数
    std::uniform_real_distribution<> distrib_real(0.0, 1.0); // 生成0到1之间的浮点数

    // 3. 生成随机数
    int random_int = distrib_int(gen);
    double random_real = distrib_real(gen);

    std::cout << "随机整数: " << random_int << std::endl;
    std::cout << "随机浮点数: " << random_real << std::endl;

    return 0;
}
```

## 智能指针

1. **`std::unique_ptr`**：
   - **特点**：独占式智能指针，确保同一时间只有一个`unique_ptr`拥有所指向的对象。
   - **使用**：通过`std::move`可以转移`unique_ptr`的所有权。
   - **示例**：

     ```cpp
     #include <memory>
     
     int main() {
         std::unique_ptr<int> ptr1 = std::make_unique<int>(10);
         std::unique_ptr<int> ptr2 = std::move(ptr1); // 转移所有权
         // ptr1 现在为空
     }
     ```

2. **`std::shared_ptr`**：
   - **特点**：共享式智能指针，允许多个`shared_ptr`实例共享同一个对象。引用计数机制用于跟踪多少个`shared_ptr`指向相同的对象，当最后一个`shared_ptr`被销毁时，对象也被销毁。
   - **使用**：不需要手动管理引用计数。
   - **示例**：

     ```cpp
     #include <memory>
     
     int main() {
         std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
         std::shared_ptr<int> ptr2 = ptr1; // 共享所有权
         // 引用计数为2
     }
     ```
