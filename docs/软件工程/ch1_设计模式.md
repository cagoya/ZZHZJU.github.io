# 设计模式

## 创建型模式

### 1.工厂模式

工厂模式定义了一个用于创建对象的接口，但让子类决定实例化哪一个类。工厂方法让类的实例化延迟到子类。简单来说，就是你有一个“工厂”来生产产品，但是具体生产哪种产品是由工厂的子类决定的。这样做有以下好处：

* 调用者只需要知道对象的名称即可创建对象。
* 扩展性高，如果需要增加新产品，只需扩展一个工厂类即可。
* 屏蔽了产品的具体实现，调用者只关心产品的接口。

### 2.抽象工厂模式

抽象工厂模式提供一个接口，用于创建一系列相关或相互依赖的对象，而无需指定它们具体的类。它允许客户端通过抽象接口来创建产品族中的产品，而不需要知道具体的产品实现。简单来说，如果说工厂模式是一个工厂生产一种产品，那么抽象工厂模式就是一个超级工厂，可以生产一系列相关的产品。这样做的好处是：

* 确保同一产品族的对象一起工作。
* 客户端不需要知道每个对象的具体类，简化了代码。

### 3.单例模式

单例模式确保一个类只有一个实例，并提供一个全局访问点。这意味着无论你在程序的哪个地方需要这个类的对象，你都会得到同一个实例。这么做的优点是：

* 内存中只有一个实例，减少内存开销，尤其是频繁创建和销毁实例时。
* 避免资源的多重占用（如写文件操作）。

单例模式有两种简单的实现方式，一种是饿汉式，另一种是懒汉式。

饿汉式，这样做的问题主要是无论是否使用，都会创建实例，浪费内存。

```cs
public class A
{
    public static A instance = new A();
    public void f()
    {
        Console.WriteLine("f");
    }
}
```

懒汉式，这样做的好处是延迟创建实例，但是缺点是线程不安全，因为有可能多个线程同时访问到 instance 为 null 的情况，这样会导致创建多个实例，可以通过加锁来解决。

```cs
public class A
{
    public static A instance;
    public static A GetInstance()
    {
        if (instance is null)
        {
            instance = new A();
        }
        return instance;
    }
    public void f()
    {
        Console.WriteLine("f");
    }
}
```

### 4.建造者模式

建造者模式（也叫生成器模式）允许你一步一步地创建复杂的对象。建造者模式将对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。这样做的好处是：

* 分离构建过程和表示，使得构建过程更加灵活，可以构建不同的表示。
* 可以更好地控制构建过程，隐藏具体构建细节。
* 代码复用性高，可以在不同的构建过程中重复使用相同的建造者。

这样其实可以解决构造函数参数过多的问题，尤其是对于 Python，因为 Python 不支持重载，像 Java/C++ 这种还可以重载大量不同参数组合的构造函数，但是 Python 做不到，通常只能是构造函数中每个参数都设置默认值，但是这样又会导致构造函数很复杂。

### 5.原型模式

原型模式核心思想是通过复制（克隆）现有对象来创建新对象，而不是通过传统的构造函数方式。当创建新对象的成本较高，或者需要动态地创建对象时，原型模式会非常有用。

优点是：

* 性能提高
* 避免构造函数的约束

C# 一般会用到`MemberwiseClone()`，这是`System.Object`中的一个`protected`的方法，这意味着它不能直接从外部调用，只能在其所属的类内部或者由其派生类调用。这个方法用于实现**浅拷贝**，如果需要深拷贝，需要在 `MemberwiseClone()` 的结果上进一步手动克隆引用类型字段。

## 结构型模式

### 6.适配器模式

适配器模式（Adapter Pattern）充当两个不兼容接口之间的桥梁，属于结构型设计模式。它通过一个中间件（适配器）将一个类的接口转换成客户期望的另一个接口，使原本不能一起工作的类能够协同工作。这样做的优点是：

* 促进了类之间的协同工作，即使它们没有直接的关联。
* 提高了类的复用性。
* 增加了类的透明度。
* 提供了良好的灵活性。

### 7.桥接模式

桥接模式 (Bridge Pattern) 是一种结构型设计模式，它旨在将抽象与实现解耦，使它们可以独立地变化。这种模式的核心思想是，不再是继承一个具体的实现，而是将一个实现对象作为成员变量包含在抽象中，从而通过组合的方式将两者连接起来。这样做的优点是：

* 抽象与实现分离：提高了系统的灵活性和可维护性。
* 扩展能力强：可以独立地扩展抽象和实现。
* 实现细节透明：用户不需要了解实现细节。

### 8.组合模式

### 9.装饰器模式

### 10.外观模式

### 11.享元模式

### 12.代理模式

## 行为型模式

### 13.责任链模式

### 14.命令模式

### 15.解释器模式

### 16.迭代器模式

### 17.中介者模式

### 18.备忘录模式

### 19.观察者模式

### 20.状态模式

### 21.策略模式

### 22.模版模式

### 23.访问者模式
